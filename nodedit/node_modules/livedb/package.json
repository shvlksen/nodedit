{
  "name": "livedb",
  "version": "0.5.9",
  "description": "Realtime database wrapper",
  "main": "lib/index.js",
  "dependencies": {
    "deep-is": "~0.1",
    "arraydiff": "~0.1",
    "async": "~0.7",
    "ot-text-tp2": "^1.0.0",
    "ot-text": "^1.0.0",
    "ot-json0": "^1.0.0",
    "redis": "^0.12.1",
    "hiredis": "^0.2.0",
    "statsd-client": "*"
  },
  "optionalDependencies": {
    "redis": "^0.12.1",
    "hiredis": "^0.2.0",
    "statsd-client": "*"
  },
  "devDependencies": {
    "mocha": "~1",
    "sinon": "~1",
    "coffee-script": "~1.7"
  },
  "scripts": {
    "test": "node_modules/.bin/mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/share/livedb.git"
  },
  "author": {
    "name": "Joseph Gentle",
    "email": "josephg@gmail.com"
  },
  "license": "MIT",
  "gitHead": "a95ee727e5cb43a40476f58554774b776fb08f68",
  "readme": "# LIVE DB!\n\nLivedb is a database wrapper which exposes the API that realtime databases should\nhave. All database access from ShareJS (and hence racer and derby apps) goes\nthrough a livedb client.\n\nLivedb lets submit operations (edit documents) and subscribe to documents.\nSubscribing gives you a stream of all operations applied to the given\ndocument, as they happen. You can also make live bound queries, which give you\nthe results of your query and a feed of changes to the result set over time.\n\nTo use it, you need a database to actually store your data in.\nA database wrapper for mongo is available in\n[share/livedb-mongo](https://github.com/share/livedb-mongo). I hope to add more\nover time.\n\nIf you want to mess about, livedb also has an in-memory database backend you\ncan use. The in-memory database stores all documents and operations in memory\nforever (or at least, until you restart your server - at which point all\ndocuments and operations are lost.)\n\nFor questions, discussion and announcements, join the [ShareJS mailing list](https://groups.google.com/forum/?fromgroups#!forum/sharejs).\n\nPlease report any bugs you find to the [issue tracker](https://github.com/share/livedb/issues).\n\n\n## Quick tour\n\n```javascript\nvar livedb = require('livedb');\nvar db = require('livedb-mongo')('localhost:27017/test?auto_reconnect', {safe:true});\n\nbackend = livedb.client(db);\n\nbackend.fetchAndSubscribe('users', 'fred', function(err, data, stream) {\n  // Data is simply {v:0} because the fred document doesn't exist yet.\n\n  stream.on('data', function(op) {\n    // We'll see all changes to the fred document as they happen\n    console.log('Fred was edited by the operation', op);\n  });\n});\n\n\n// This could happen from a different process / server but only if you use the\n// redis driver. (Otherwise they won't see each other's changes and everything\n// breaks)\nbackend.submit('users', 'fred', {v:0, create:{type:'json0', data:{name:'Fred'}}}, function(err) {\n  // Created with data {name:'Fred'}\n\n  // Other concurrent edits can happen too, and they'll all be merged using OT.\n  // This operations says at doc['name'][4], insert characters ' Flintstone'.\n  backend.submit('users', 'fred', {v:1, op:[{p:['name', 4], si:' Flintstone'}]}, function(err) {\n    // users.fred now has data {name:'Fred Flintstone'}\n  });\n});\n```\n\n\n## Data Model\n\nIn LiveDB's view of the world, every document has 3 properties:\n\n- **version**: an incrementing number starting at 0\n- **type**: an OT type. OT types are defined in\n[share/ottypes](https://github.com/share/ottypes). Types are referenced using\ntheir URIs (even though those URIs don't actually mean anything). Documents\nwhich don't exist implicitly have a type of `null`.\n- **data**: The actual data that the document contains. This must be pure\nacyclic JSON. Its also type-specific. (JSON type uses raw JSON, text documents\nuse a string, etc).\n\nLiveDB implicitly has a record for every document you can access. New documents\nhave version 0, a null type and no data. To use a document, you must first\nsubmit a *create operation*, which will set the document's type and give it\ninitial data. Then you can submit editing operations on the document (using\nOT). Finally you can delete the document with a delete operation. By\ndefault, livedb stores all operations forever - nothing is truly deleted.\n\n---\n\n## Using Livedb\n\nLivedb requires 3 puzzle pieces to operate:\n\n- A snapshot database, to store actual documents.\n- An oplog to store historical operations. We currently require that operations\n  are stored forever, but I want to change this before 1.0. (It might work\n  today, but we're missing tests).\n- A livedb driver. If you have multiple servers, the driver manages\n  communication between them all. The driver also makes commits atomic (so\n  servers won't clobber each other's changes) and publishes operations.  If you\n  only have one frontend server, you can use the inprocess driver. (This is the\n  default if you do not specify a driver.)\n\nYou can put operations and snapshot data in different places if you want, but\nits easier to put all of your data in the same database.\n\nThe backend database(s) needs to implement a [simple API which has\ndocumentation and a sample implementation\nhere](https://github.com/share/livedb/blob/master/lib/memory.js). Currently the\nonly database binding is [livedb-mongo](https://github.com/share/livedb-mongo).\n\nA livedb client is created using either an options object or a database\nbackend. If you specify a database backend, its used as both oplog and\nsnapshot.\n\n```javascript\ndb = require('livedb-mongo')('localhost:27017/test?auto_reconnect', {safe:true});\nbackend = livedb.client(db);\n```\n\nThis is the equivalent to this:\n\n```javascript\ndb = require('livedb-mongo')('localhost:27017/test?auto_reconnect', {safe:true});\nbackend = livedb.client({db:db});\n// Also equivalent to livedb.client({snapshotDb:db, oplog:db});\n```\n\nYou can use a different database for both snapshots and operations if you want:\n\n```javascript\nsnapshotdb = require('livedb-mongo')('localhost:27017/test?auto_reconnect', {safe:true});\noplog = {writeOp:..., getVersion:..., getOps:...};\nbackend = livedb.client({snapshotDb:snapshotdb, oplog:oplog});\n```\n\nAll of the above examples will use the in-process driver by default. If you\nwant to scale across multiple frontend servers, you should use the redis driver:\n\n```javascript\nvar redis = require('redis');\nclient1 = redis.createClient(6379, '192.168.1.123', auth_pass:'secret');\nclient2 = redis.createClient(6379, '192.168.1.123', auth_pass:'secret');\n\ndriver = livedb.redisDriver(oplog, client1, client2);\nbackend = livedb.client({snapshotDb:snapshotdb, driver:driver});\n```\n\nThe redis driver needs 2 redis clients because redis can't use the same\nconnection for commands and pubsub. [See node-redis documentation for help\nconfiguring\nredis](https://github.com/mranney/node_redis#rediscreateclientport-host-options).\n\n\nThe options object can also be passed:\n\n- **extraDbs:** *{name:query db}* This is used to register extra database\n  backends which will be notified whenever operations are submitted. They can\n  also be used in queries.\n- **sdc:** A pre-configured\n  [node-statsd-client](https://github.com/msiebuhr/node-statsd-client) client\n  to send monitoring information. Note that the events livedb logs to statsd\n  are not considered part of the public API, and may change at any time.\n\n### Creating documents\n\nTo create a document, you need to submit a create operation to the\ndocument to set its type. In livedb's world, a document doesn't exist until it\nhas a type set.\n\nA create operation looks like this: `{create:{type:TYPE, [data:INITIAL DATA]}, [v:VERSION]}`. The type should be something accessible in the map returned by require('ottypes'), for example `json0` or `http://sharejs.org/types/textv1`. Specifying initial data is optional. If provided, it is passed to the type's `create()` method. This does what you expect - for JSON documents, pass your initial object here. For text documents, pass a string containing the document's contents. As with all operations, the version is optional. You probably don't want to specify the version for a create message.\n\nTo submit any changes to documents, you use `livedb.submit(cName, docName, opData, callback)`.\n\nFor example:\n\n```javascript\nlivedb.submit('users', 'fred', {create:{type:'json0', data:[1,2,3]}}, function(err, version, transformedByOps, snapshot) {\n  // I made a document, ma!\n});\n```\n\nSince documents implicitly exist with no type at version 0, usually the create\nmessage will increment the version from 0 to 1. Not all documents you want to\ndelete have a version of 0 - if a document is deleted, it will retain its\nversion.\n\n### Deleting documents\n\nDeleting documents is similar to creating them. A deleted document has no type\nand no data, but will retain its version (actually, the delete operation will\nbump the document's version). A delete operation looks like this:\n`{del:true, [v:VERSION]}`.\n\nYou use the same submit function as above to delete documents:\n\n```javascript\nlivedb.submit('users', 'fred', {del:true}, function(err) {\n  //goneskies! Kapow!\n});\n```\n\n### Editing documents\n\nYou edit a document by submitting an operation. Operations are OT type-specific\nJSON blobs. Refer to the documentation on the particular OT type for details.\nFor example, text documents are documented\n[here](https://github.com/share/ottypes/blob/master/lib/text.js#L10-L16). If we\nhad a text document stored in LiveDB and wanted to edit it, it might look like\nthis:\n\n```javascript\nlivedb.submit('love letters', 'dear fred', {op:[6, \"You never return my calls!\"], v:1002}, function(err) {\n  // ...\n});\n```\n\nYou should always specify the version when submitting edit operations. The\nversion is technically optional - if its missing, your operation will be\nsubmitted against the most recent version of the document in the server. This\nis useful for creating a document which may already exist, but for normal edits\nyou should always specify the expected current version of the document.\n\n\n### Getting a document\n\nYou can fetch the most recent version of a document using `livedb.fetch(cName, docName, callback)` or\n`livedb.bulkFetch(request, callback)`. This will fetch the document(s) from the snapshot database\nand fetch all operations which may or may not have been committed.\n\nFetch returns a snapshot data object via its callback. The snapshot data object\nhas the following fields:\n\n- **v:** version. This is an integer (starting at 0) containing the version of the document\n- **type:** Document type, if set. This field is missing if the document does not exist.\n- **data:** The document's actual data. For JSON documents this is a JSON tree.\n  For text documents this is a string. This field is missing if the document does not exist.\n\n```javascript\nlivedb.fetch('users', 'fred', function(err, snapshot) {\n  // snapshot has {v:123, type:'...', data:{name:'Fred Flintstone'}}\n  // If the document doesn't exist, only the v:version field will exist in the data.\n});\n```\n\nIf you need to get many documents, its more efficient to issue bulk fetches. To\npass the set of requested documents to bulkFetch, you need to make a request\nobject which maps collection names to lists of documents you want in that\ncollection. For example, to get 'red', 'green' and 'blue' from the colors\ncollection, you would make a bulkFetch request of `{colors:['red', 'green',\n'blue']}`.\n\nThe response maps each collection name to a set of snapshots. Each set of\nsnapshots maps document names to snapshot data objects. Continuing our colors\nexample above, the response could be `{colors:{red:{v:0}, green:{v:10, type:..., data:\"emerald\"}, blue:{v:1, type:..., data:{favorite:true}}}}`.\n\nFor example:\n\n```javascript\nlivedb.bulkFetch({users:['fred', 'wilma', 'homer'], admins:['zerocool']}, function(err, results) {\n  // results will be {users:{fred:..., wilma:..., homer:...}, admins:{zerocool:...}}.\n  // Each document has v and optional type and data fields like fetch (above).\n});\n```\n\n\n### Getting historic changes to a document\n\nYou can get old versions of a document (for playback or catching up a client)\nusing `livedb.getOps(cName, docName, from, to, callback)`. This will return\nall operations which have been applied to the named document in the requested range.\nThe range is *open*, so `getOps('users', 'fred', 0, 3, ..)` will return all\noperations up to (but not including) 3. (Ie, operations 0, 1 and 2).\n\nIf you set the *to* field to null, getOps will get all operations up to the\ncurrent version.\n\nLivedb documents always start at version 0, so you can get a document's entire history using `getOps('users', fred', 0, null, callback);`.\n\nIf you set *to* to a version in the future, behaviour is not defined.\n\nExample usage:\n\n```javascript\nlivedb.submit('users', 'fred', {create:{type:'json0', data:{name:'Fred'}}}, function(err) {\n  livedb.submit('users', 'fred', {v:1, op:[{p:['name', 4], si:' Flintstone'}]}, function(err) {\n    // ...\n  });\n});\n\n// ---- Sometime later...\n\nlivedb.getOps('users', 'fred', 0, null, function(err, ops) {\n  // ops contains the two operations which were submitted above:\n  // [{v:0, create:{...}, {v:1, op:[...]}]\n});\n```\n\n### Streaming changes to a document in realtime\n\nYou can subscribe to changes from a document using\n`livedb.subscribe(cName, docName, v, callback)` or\n`livedb.bulkSubscribe(request, callback)`. When you subscribe, you get an\noperation stream which gets packed with operations as they happen.\n\nWhen you subscribe to a document, you need to specify which version you're\nsubscribing to the document *from*. The version cannot be in the future.\n\nThe stream will be populated with each operation from the requested version\nonwards (to infinity and beyond). Each operation will appear in the stream\nexactly once. If you subscribe and request an old document version, all\noperations from that version to the current version will be buffered in the\nstream before the stream is returned to the callback.\n\nYou usually want to call *subscribe* after fetching a document. Pass the\ndocument version that you got from calling *fetch* into your call to\n*subscribe*.\n\nFor example:\n\n```javascript\nlivedb.fetch('users', 'fred', function(err, data) {\n  if (err) { ... }\n  var version = data.v;\n\n  // ... Any amount of time later (literally).\n  livedb.subscribe('users', 'fred', version, function(err, stream) {\n    if (err) { ... }\n\n    // stream is a nodejs ReadableStream with all operations that happen to\n    // users.fred.\n\n    stream.on('data', function(opData) {\n      // The opData is a JSON object, the same object you can pass to submit().\n      // It always has a v: field.\n\n      // Livedb exports a helper function to apply the operation to some\n      // snapshot data:\n      var err = ldb.ot.apply(data, opData);\n      if (err) { ... }\n    });\n  });\n});\n```\n\n**Important!** To avoid leaking memory, when you're done with a stream call `stream.destroy()` to clean it up.\n\nThere is a helper method which will both fetch and subscribe for you (cleverly\ncalled `fetchAndSubscribe(cName, docName, callback)`). It is defined like this:\n\n```javascript\nLivedb.prototype.fetchAndSubscribe = function(cName, docName, callback) {\n  var self = this;\n  this.fetch(cName, docName, function(err, data) {\n    if (err) return callback(err);\n    self.subscribe(cName, docName, data.v, function(err, stream) {\n      callback(err, data, stream);\n    });\n  });\n};\n```\n\nIt calls your callback with `(err, snapshot, stream)`, giving you both the current document snapshot and the stream of operations from the current version.\n\n#### Bulk Subscribe\n\nIf you want to subscribe to multiple documents at once, you should call\n`bulkSubscribe(request, callback)`. The bulk subscribe request is a map from\ncName -> map from docName -> version. For example, `{colors: {red:5, blue:6,\ngreen:0}}`. The response is a map from cName -> map from docName -> stream.\nFor example, `{colors: {red:<stream>, blue:<stream>, green:<stream>}}`.\nbulkSubscribe will either return a stream for all requested objects or (if\nthere was an error), none of them.\n\nAgain, remember to call `stream.destroy()` on all streams returned by bulk\nsubscribe when you're done with them.\n\n\n### Queries\n\nLivedb supports running live queries against the database. It can re-run queries when it suspects that a query's results might have changed - and notify the caller with any changes to the result set.\n\nThis is incredibly inefficient and I want to completely rewrite / rework them. For now, I recommend against using live bound queries in a production app with a decent load. I'll document them when I'm happier with them.\n\n\n### Projections\n\nLivedb supports exposing a *projection* of a real collection, with a specified\n(limited) set of allowed fields. Once configured, the projected collection\nlooks just like a real collection - except documents only have the fields\nyou've requested.\n\nOperations (gets, queries, sets, etc) on the fake collection work, but you only\nsee a small portion of the data. You can use this to drop server & db load\ndramatically and speed up page times. Its similar to SQL VIEWs. For now, this\nonly works on JSON documents. (I don't know what it would look like for text\ndocuments).\n\nFor example, you could make a `users_limited` projection which lets users view\neach other's names and profile pictures, but not password hashes. You would\nconfigure this by calling:\n\n```javascript\nlivedb.addProjection('users_limited', 'users', 'json0', {name:true, profileUrl:true});\n```\n\nHowever, be aware that on its own **this is not sufficient for access control**. If\nusers are still allowed to make arbitrary mongo queries against the projected\ncollection, they can find out any data in the hidden fields.\n\nConfigure a projection by calling `addProjection(projCName, realCName, type, fields)`.\n\n- **projCName:** The projected collection name. (Eg, `users_limited`)\n- **realCName:** The underlying collection name\n- **type:** The OT type. Only JSON0 is supported for now.\n- **fields:** A map of the allowed fields in documents. The keys in this map\n  represent the field names, and the values should be `true`.\n\nLimitations:\n\n- You can only whitelist fields (not blacklist them).\n- The third parameter must be 'json0'.\n- Projections can only limit / allow fields at the top level of the document\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/share/livedb/issues"
  },
  "_id": "livedb@0.5.9",
  "_from": "livedb@"
}
